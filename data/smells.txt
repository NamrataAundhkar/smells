[smell]
[smell-id]MA
[smell-category]DESIGN
[smell-name]Missing Abstraction
[smell-description]This smell arises when clumps of data or encoded strings are used instead of creating a class or an interface.
[smell-ref]Girish
[smell-aka]PO
[smell-aka]DC
[smell-end]

[smell]
[smell-id]IA
[smell-category]DESIGN
[smell-name]Imperative Abstraction
[smell-description]This smell arises when an operation is turned into a class.
[smell-ref]Girish
[smell-aka]POL
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]IA2
[smell-category]DESIGN
[smell-name]Incomplete Abstraction
[smell-description]This smell arises when an abstraction does not support complementary or interrelated methods completely.
[smell-ref]Girish
[smell-aka]ILC
[smell-end]

[smell]
[smell-id]MA2
[smell-category]DESIGN
[smell-name]Multifaceted Abstraction
[smell-description]This smell arises when an abstraction has more than one responsibility assigned to it.
[smell-ref]Girish
[smell-aka]DC3
[smell-aka]SAK
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]UA
[smell-category]DESIGN
[smell-name]Unnecessary Abstraction
[smell-description]This smell occurs when an abstraction that is actually not needed (and thus could have been avoided) gets introduced in a software design.
[smell-ref]Girish
[smell-aka]LC2
[smell-aka]POL
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]UA2
[smell-category]DESIGN
[smell-name]Unutilized Abstraction
[smell-description]This smell arises when an abstraction is left unused (either not directly used or not reachable).
[smell-ref]Girish
[smell-aka]SG
[smell-aka]OC
[smell-aka]UP
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]DA
[smell-category]DESIGN
[smell-name]Duplicate Abstraction
[smell-description]This smell arises when two or more abstractions have identical names or identical implementation or both.
[smell-ref]Girish
[smell-aka]ACDI
[smell-aka]CPP
[smell-aka]DC2
[smell-aka]UH2
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]DE
[smell-category]DESIGN
[smell-name]Deficient Encapsulation
[smell-description]This smell occurs when the declared accessibility of one or more members of an abstraction is more permissive than actually required.
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]LE
[smell-category]DESIGN
[smell-name]Leaky Encapsulation
[smell-description]This smell arises when an abstraction "exposes" or "leaks" implementation details through its public interface.
[smell-ref]Girish
[smell-aka]VDG
[smell-aka]SAB
[smell-end]

[smell]
[smell-id]ME
[smell-category]DESIGN
[smell-name]Missing Encapsulation
[smell-description]This smell occurs when implementation variations are not encapsulated within an abstraction or hierarchy.
[smell-ref]Girish
[smell-end]

[smell]
[smell-id]UE
[smell-category]DESIGN
[smell-name]Unexploited Encapsulation
[smell-description]This smell arises when client class uses explicit type checks (using chained if-else or switch statements that check for the type of the object) instead of exploiting the variation in types already encapsulated within a hierarchy.
[smell-ref]Girish
[smell-aka]SS2
[smell-aka]TQ
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]BM
[smell-category]DESIGN
[smell-name]Broken Modularization
[smell-description]This smell arises when data and/or methods that ideally should have been localized into a single abstraction are separated and spread across multiple abstractions.
[smell-aka]DC4
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]IM
[smell-category]DESIGN
[smell-name]Insufficient Modularization
[smell-description]This smell arises when an abstraction exists that has not been completely decomposed, and a further decomposition could reduce its size, implementation complexity, or both.
[smell-aka]LC
[smell-aka]GC
[smell-aka]BL
[smell-aka]SAK
[smell-aka]TLP
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]CM
[smell-category]DESIGN
[smell-name]Cyclically-dependent Modularization
[smell-description]This smell arises when two or more abstractions depend on each other directly or indirectly.
[smell-aka]SCDG
[smell-aka]DCP
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]HM
[smell-category]DESIGN
[smell-name]Hub-like Modularization
[smell-description]This smell arises when an abstraction has dependencies (both incoming and outgoing) with a large number of other abstractions.
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]MH
[smell-category]DESIGN
[smell-name]Missing Hierarchy
[smell-description]This smell arises when a DESIGN segment uses conditional logic to explicitly manage variation in behavior where a hierarchy could have been created and used to encapsulate those variations.
[smell-aka]SS2
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]UH
[smell-category]DESIGN
[smell-name]Unnecessary Hierarchy
[smell-description]This smell arises when the whole inheritance hierarchy is unnecessary, indicating that inheritance has been applied needlessly for the particular design context.
[smell-ref]Girish
[smell-end]

[smell]
[smell-id]UH2
[smell-category]DESIGN
[smell-name]Unfactored Hierarchy
[smell-description]This smell arises when there is unnecessary duplication among types in a hierarchy.
[smell-aka]CPP
[smell-aka]DA
[smell-aka]DC2
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]WH
[smell-category]DESIGN
[smell-name]Wide Hierarchy
[smell-description]This smell arises when an inheritance hierarchy is "too" wide indicating that intermediate types may be missing.
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]SH
[smell-category]DESIGN
[smell-name]Speculative Hierarchy
[smell-description]This smell arises when one or more types in a hierarchy are provided speculatively (i.e., based on imagined needs rather than real requirements).
[smell-aka]SG
[smell-ref]Girish
[smell-end]

[smell]
[smell-id]DH
[smell-category]DESIGN
[smell-name]Deep Hierarchy
[smell-description]This smell arises when an inheritance hierarchy is "excessively" deep.
[smell-aka]TDIH
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]RH
[smell-category]DESIGN
[smell-name]Rebellious Hierarchy
[smell-description]This smell arises when a subtype rejects the methods provided by its supertype(s).
[smell-aka]RB
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]BH
[smell-category]DESIGN
[smell-name]Broken Hierarchy
[smell-description]This smell arises when a supertype and its subtype conceptually do not share an "IS-A" relationship resulting in broken substitutability.
[smell-aka]SDRM
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]MH2
[smell-category]DESIGN
[smell-name]Multipath Hierarchy
[smell-description]This smell arises when a subtype inherits both directly as well as indirectly from a supertype leading to unnecessary inheritance paths in the hierarchy.
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]CH
[smell-category]DESIGN
[smell-name]Cyclic Hierarchy
[smell-description]This smell arises when a supertype in a hierarchy depends on any of its subtypes.
[smell-ref]Girish
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]DC2
[smell-category]IMPL
[smell-name]Duplicate Code
[smell-description]This smell occurs when same code structure is duplicated to multiple places within a software system. Fowler defined it as follows: "If you see the same code structure in more than one place, you can be sure that your program will be better if you find a way to unify them."
[smell-aka]DA
[smell-aka]UH2
[smell-aka]CPP
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]LM
[smell-category]IMPL
[smell-name]Long Method
[smell-description]This smell occurs when a method is too long to understand. As Fowler says "...the longer a procedure (method) is, the more difficult it is to understand."
[smell-aka]
[smell-ref]Fowler
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]LC
[smell-category]DESIGN
[smell-name]Large Class
[smell-description]This smell occurs when a class is large containing too many variables and methods. A large size class is not only difficult to understand but also leads to other smells. As Fowler says "...a class with too many instance variables, a class with too much code is prime breeding ground for duplicated code, chaos, and death."
[smell-aka]IM
[smell-aka]GC
[smell-aka]BL
[smell-aka]TLP
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]LPL
[smell-category]IMPL
[smell-name]Long Parameter List
[smell-description]This smell occurs when a method accepts a long list of parameters. According to Fowler "...long parameter lists are hard to understand, because they become inconsistent and difficult to use, and because you are forever changing them as you need more data."
[smell-aka]
[smell-ref]Fowler
[smell-tool]DESIGNITE
[smell-tool]DESIGNITEJAVA
[smell-end]

[smell]
[smell-id]DC3
[smell-category]DESIGN
[smell-name]Divergent Change
[smell-description]Divergent change occurs when one class is commonly changed in different ways for different reasons.
[smell-aka]MA2
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]SS
[smell-category]DESIGN
[smell-name]Shotgun Surgery
[smell-description]This smell characterizes the situation when one kind of change leads to a lot of changes to multiple different classes. When the changes are all over the place, they are hard to find, and it's easy to miss an important change.
[smell-aka]
[smell-ref]Fowler
[smell-end]


[smell]
[smell-id]FE
[smell-category]DESIGN
[smell-name]Feature Envy
[smell-description]This smell occurs when a method seems more interested in a class other than the one it actually is in.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]DC
[smell-category]DESIGN
[smell-name]Data Clumps
[smell-description]This smell occurs when a set of data items dispatched (as parameters to other methods) and used together. Such a bunch of data items must be encapsulated in an abstraction.
[smell-aka]MA
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]PO
[smell-category]DESIGN
[smell-name]Primitive Obsession
[smell-description]This smell occurs when primitive data types are used where an abstraction encapsulating the primitives could serve better.
[smell-aka]MA
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]SS2
[smell-category]DESIGN
[smell-name]Switch Statement
[smell-description]This smell occurs when switch statements that switches on type codes are spread across the software system instead of exploiting polymorphism.
[smell-aka]UE
[smell-aka]MH
[smell-aka]TQ
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]PIH
[smell-category]DESIGN
[smell-name]Parallel Inheritance Hierarchies
[smell-description]This smell occurs when introducing a subclass of one class leads to creation of another subclass of another class. It is a special case of shotgun surgery.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]LC2
[smell-category]DESIGN
[smell-name]Lazy Class
[smell-description]This smell occurs where a class is not doing enough i.e. it does not realize a concrete responsibility. Fowler says that "Each class you create costs money to maintain and understand. A class that isn't doing enough to pay for itself should be eliminated."
[smell-aka]UA
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]SG
[smell-category]DESIGN
[smell-name]Speculative Generality
[smell-description]This smell occurs where an abstraction is created based on speculated requirements. It is often unnecessary that makes things difficult to understand and maintain.
[smell-aka]UA2
[smell-aka]SH
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]TF
[smell-category]IMPL
[smell-name]Temporary Field
[smell-description]This smell occurs when an instance variable is set only in certain circumstances. It makes the code difficult to understand since the purpose of the variable is not clear enough.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]MC
[smell-category]DESIGN
[smell-name]Message Chains
[smell-description]This smell occurs when an object is acquired by a series of object getters. Such a message chain indicate that the client is coupled to the structure of the navigation and thus, any change to the intermediate relationships causes the client to change.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]MM
[smell-category]DESIGN
[smell-name]Middle Man
[smell-description]This smell occurs when a class is used as a middleman to merely delegate the messages from clients to classes that are implementing some useful functionality without contributing anything to the application.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]II
[smell-category]DESIGN
[smell-name]Inappropriate Intimacy
[smell-description]This smell occurs when classes become far too intimate and spend too much time delving in each others' private parts.
[smell-aka]
[smell-ref]Fowler
[smell-end]


[smell]
[smell-id]ACDI
[smell-category]DESIGN
[smell-name]Alternative Classes with Different Interfaces
[smell-description]This smell occurs when alternative classes offer different interfaces to their clients. Such classes make it difficult for the clients to use them (for instance, explicitly checking for their type).
[smell-aka]DA
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]ILC
[smell-category]DESIGN
[smell-name]Incomplete Library Class
[smell-description]This smell occurs when a library class doesn't fulfil the requirements of a user completely.
[smell-aka]
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]DC4
[smell-category]DESIGN
[smell-name]Data Class
[smell-description]This smell occurs when a class contains only fields and possibly getters/setters without any behavior (methods).
[smell-aka]BM
[smell-ref]Fowler
[smell-end]

[smell]
[smell-id]RB
[smell-category]DESIGN
[smell-name]Refused Bequest
[smell-description]This smell occurs when a subclass rejects some of the methods or properties offered by its superclass.
[smell-aka]RH
[smell-ref]Fowler
[smell-end]


[smell]
[smell-id]CO
[smell-category]IMPL
[smell-name]Comments
[smell-description]This smell occurs when comments are used as deodorant to explain the bad code.
[smell-aka]
[smell-ref]Fowler
[smell-end]


[smell]
[smell-id]POL
[smell-category]DESIGN
[smell-name]Poltergeist
[smell-description]The smell occurs when classes are created that have limited responsibility within the operation of a system. It can appear in a number of different forms but their idea is the same, poltergeist classes do not have an important role in an OO design. Furthermore, poltergeist classes have a short life cycle and represent a waste of resources when they are used. \nRiel classifies 5 different ways in which this anti-pattern may appear in an OO design. 1) Irrelevant classes: An irrelevant class is a class that does not have any meaningful behaviour in the design. These types of classes are characterised for being composed only of get, set and/or print methods, 2) Agent classes: Agent classes are classes that are formed by methods that are only responsible for passing messages from one class to another, 3) Out of scope classes: A class is classified as out of the scope of the system if it sends messages to other classes but it never receives any message back, 4) Operation classes: Operation classes are characterised for being composed of only one meaningful behaviour and for having a short life cycle, and 5) Object classes: Object classes are subclasses that should be instances of their parent class instead of being classes themselves.
[smell-aka]IA
[smell-aka]UA
[smell-ref]Riel
[smell-end]

[smell]
[smell-id]GC
[smell-category]DESIGN
[smell-name]God Class
[smell-description]The God class smell occurs when a huge class which is surrounded by many data classes acts as a controller (i.e. takes most of the decisions and monopolises the functionality offered by the software). The class defines many data members and methods and exhibits low cohesion.
[smell-aka]IM
[smell-aka]BL
[smell-aka]LC
[smell-aka]TLP
[smell-ref]Riel
[smell-end]

[smell]
[smell-id]BL
[smell-category]DESIGN
[smell-name]The Blob
[smell-description]The Blob is found in designs where one class monopolizes the processing, and other classes primarily encapsulate data. The key problem here is that the majority of the responsibilities are assigned to a single class.
[smell-aka]IM
[smell-aka]GC
[smell-aka]LC
[smell-aka]TLP
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]LF
[smell-category]DESIGN
[smell-name]Lava Flow
[smell-description]This smell is characterized by a piece of code that nobody remember the purpose and usage, and is largely not utilized.
[smell-aka]
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]FD
[smell-category]DESIGN
[smell-name]Functional Decomposition
[smell-description]This smell occurs when the experienced developers coming from procedural languages background write highly procedural and non-object-oriented code in an object-oriented language. When developers are comfortable with a "main" routine that calls numerous subroutines, they may tend to make every subroutine a class, ignoring class hierarchies altogether (and pretty much ignoring object orientation entirely).
[smell-aka]TDG
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]GH
[smell-category]DESIGN
[smell-name]Golden Hammer
[smell-description]This smell results in the misapplication of a favored tool, library, language, framework, or concept. Developers and managers are comfortable with an existing approach and unwilling to learn and apply one that is better suited.
[smell-aka]
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]SC
[smell-category]DESIGN
[smell-name]Spaghetti Code
[smell-description]This smell refers to an unmaintainable, incomprehensible code without any structure. Spaghetti Code does not exploit and prevents the use of object-orientation mechanisms and concepts.
[smell-aka]
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]CPP
[smell-category]DESIGN
[smell-name]Cut and Paste Programming
[smell-description]This smell is identified by the presence of several similar segments of code interspersed throughout the software project.
[smell-aka]DC2
[smell-aka]DA
[smell-aka]UH2
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]AS
[smell-category]ARCH
[smell-name]Autogenerated Stovepipe
[smell-description]This smell arises when existing software system is converted to a distributed infrastructure without considering a change in the design and architecture of the system.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]SE
[smell-category]ARCH
[smell-name]Stovepipe Enterprise
[smell-description]This smell is characterized by a lack of a software structure that inhibits change. The smell shows lack of coordination and planning across a set of systems.
[smell-aka]SS1
[smell-ref]Brown
[smell-end]


[smell]
[smell-id]JU
[smell-category]ARCH
[smell-name]Jumble
[smell-description]This smell arises when horizontal and vertical design elements are intermixed leading to an unstable architecture. The intermingling of design elements limits the reusability and robustness of the architecture.
[smell-ref]Brown
[smell-end]


[smell]
[smell-id]SS1
[smell-category]ARCH
[smell-name]Stovepipe System
[smell-description]This smell arises when subsystems are integrated in an ad hoc manner using multiple integration strategies and mechanisms.
[smell-aka]SE
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]CYA
[smell-category]ARCH
[smell-name]Cover Your Assets
[smell-description]This smell arises when a development team adopt document-driven software processes where authors of the documents take a safer course to avoid making a mistake. Such processes often produce less-than-useful requirements and specifications because the authors evade making important decisions.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]VLI
[smell-category]ARCH
[smell-name]Vendor Lock−In
[smell-description]This smell occurs in systems that are highly dependent upon proprietary architectures.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]WT
[smell-category]ARCH
[smell-name]Wolf Ticket
[smell-description]This smell occurs when conformance to standards are not enforced despite claiming openness and conformance to standards. This leads to proprietary interfaces that may vary significantly from the published standard.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]AI
[smell-category]ARCH
[smell-name]Architecture by Implication
[smell-description]This smell occurs when risk management of a new software system development is overlooked due to overconfidence and recent successes.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]WB
[smell-category]ARCH
[smell-name]Warm Bodies
[smell-description]Skilled programmers are essential to the success of a software project. This smell occurs when people with varying skills and productivity levels are assigned to a project merely to meet staff size objectives.
[smell-ref]Brown
[smell-end]


[smell]
[smell-id]DBC
[smell-category]ARCH
[smell-name]Design by Committee
[smell-description]This smell arises when a dedicated committee is formed to design and architecture the system. Design by Committee creates overly complex architectures that lack coherence.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]SAK
[smell-category]DESIGN
[smell-name]Swiss Army Knife
[smell-description]This smell arises when the designer attempts to provide all possible uses of the class and ends up in an excessively complex class interface.
[smell-ref]Brown
[smell-aka]MA2
[smell-aka]IM
[smell-end]

[smell]
[smell-id]RW
[smell-category]ARCH
[smell-name]Reinvent the Wheel
[smell-description]The pervasive lack of technology transfer between software projects leads to substantial reinvention. Design knowledge buried in legacy assets can be leveraged to reduce time−to−market, cost, and risk.
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]GODY
[smell-category]ARCH
[smell-name]The Grand Old Duke of York
[smell-description]This smell occurs when developers (or implementers) couldn't identify the significance of good abstractions and ignore them even after suggested by some team members (referred as abstractionist).
[smell-aka]MA
[smell-ref]Brown
[smell-end]

[smell]
[smell-id]OC
[smell-category]DESIGN
[smell-name]Obsolete Classes
[smell-description]This smell occurs when certain classes are no longer used in a software system. Classes that are no longer in use will burden the system with obviously obsolete functionality. A specific case of this smell occurs when a class implements more than a single responsibility and one of the responsibilities becomes unused in the meantime. Unused classes mainly emerge for two reasons - a developer speculates that the class might eventually be used and a formerly required class becomes obsolete due to refactorings.
[smell-aka]UA2
[smell-aka]UP
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TDG
[smell-category]DESIGN
[smell-name]Tree-like Dependency Graph
[smell-description]This smell occurs when each class of the tree is used by exactly one other class. Tree-like dependency graphs indicate a functional decomposition of the system.
[smell-aka]FD
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]SCDG
[smell-category]DESIGN
[smell-name]Static Cycles in Dependency Graphs
[smell-description]Two classes using each other constitute the simplest imaginable cycle in a dependency graph. The presence of many cycles in a system will lead to its lumping.
[smell-aka]CM
[smell-aka]DCP
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]VDG
[smell-category]DESIGN
[smell-name]Visibility of Dependency Graphs
[smell-description]This smell occurs when the internal implementation of a class is not hidden behind an interface.
[smell-aka]LE
[smell-aka]SAB
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TQ
[smell-category]DESIGN
[smell-name]Type Queries
[smell-description]Type queries in the system (e.g., using instanceof) can be regarded as smells: the inheritance relation expresses itself not only in the classes of the inheritance hierarchy, but in the clients too. In regard to the design principles, type queries violate the Once and only once principle (or, DRY - Don't Repeat Yourself principle).
[smell-aka]UE
[smell-aka]SS2
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]LIH
[smell-category]DESIGN
[smell-name]List-like Inheritance Hierarchy
[smell-description]In a list-like inheritance hierarchy each class possesses a maximum number of one subclass. Speculative generalization means that superclasses were implemented for a definitely required class in the hope that the created abstraction might come in handy later on.
[smell-aka]SH
[smell-aka]SG
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]SDRM
[smell-category]DESIGN
[smell-name]Subclasses Do Not Redefine Methods
[smell-description]If subclasses do not redefine the methods of their superclass, this can indicate that no abstraction is expressed through inheritance – we are facing pure implementation inheritance. Often a uses relation between classes will turn out to be more effective.
[smell-aka]BH
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]IHWPA
[smell-category]DESIGN
[smell-name]Inheritance Hierarchies Without Polymorphic Assignments
[smell-description]Inheritance hierarchies without their respective polymorphic assignments point to the presence of unnecessary generalizations. If no polymorphic assignments exist, this flexibility will not be used, and inheritance can be replaced by uses relations.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TDIH
[smell-category]DESIGN
[smell-name]Too Deep Inheritance Hierarchy
[smell-description]Deep inheritance hierarchies can result in extremely flexible systems. Unfortunately, at the same time the system’s understandability and the adaptability of its inheritance hierarchies suffers. If inheritance takes place across 10 levels, it is almost impossible to determine which implementation of a method is called by reading the code.
[smell-aka]DH
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]UP
[smell-category]ARCH
[smell-name]Unused Packages
[smell-description]Packages that are not in use burden the system with clearly obsolete functionality.
[smell-aka]OC
[smell-aka]UA2
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]DCP
[smell-category]ARCH
[smell-name]Dependency Cycles between Packages/Subsystems
[smell-description]This smell occurs when two or more packages/subsystems depend on each other. Cycles between packages/subsystems can be created through use, inheritance, or through a combination of use and inheritance.
[smell-aka]SCDG
[smell-aka]CM
[smell-aka]CMC
[smell-ref]Lippert
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]TSP
[smell-category]ARCH
[smell-name]Too Small Packages/Subsystems
[smell-description]Packages/Subsystems with one or two classes are often not worth the effort of introducing them: the complexity created by the package/subsystem is not offset by its additional structuring.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TLP
[smell-category]ARCH
[smell-name]Too Large Packages/Subsystems
[smell-description]Packages/Subsystems with a high number of classes/packages indicate that they serve more than one specific responsibility. Splitting them up will lead to a better separation of concerns and especially to better understandability.
[smell-aka]IM
[smell-aka]GC
[smell-aka]LC
[smell-aka]BL
[smell-ref]Lippert
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]PHU
[smell-category]ARCH
[smell-name]Package Hierarchies Unbalanced
[smell-description]This smell arises when package structure of a software system is unbalanced. If the package structure is unbalanced, understandability is impaired.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]PNCN
[smell-category]ARCH
[smell-name]Packages Not Clearly Named
[smell-description]Especially packages containing classes that are not domain-oriented are often named ambiguously, and assigning of identical names occurs. If various packages with names like util, base, framework and toolkit can be found side by side in the same system and on the same level, it will be hard for developers to find the package containing the desired class right away.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]NS
[smell-category]ARCH
[smell-name]No Subsystems
[smell-description]From a certain size on, a system’s structure – if it is defined exclusively on the package level – will become increasingly incomprehensible. If the system consists of more than 100 packages, for example, it is extremely difficult to recognize and define the structure between the packages and to maintain it consistently.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TMS
[smell-category]ARCH
[smell-name]Too Many Subsystems
[smell-description]If a system consists of many more than 30 subsystems without further grouping, the understandability of the system will be seriously impaired. This many subsystems and their interrelations can no longer be handled.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]SAB
[smell-category]ARCH
[smell-name]Subsystem-API Bypassed
[smell-description]Bypassing the subsystem-API and directly accessing the internal implementation of the component is a practice that is not only common, but also potentially fatal. The clients actually unauthorizedly expand the subsystem-API.
[smell-aka]LE
[smell-aka]VDG
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]SATL
[smell-category]ARCH
[smell-name]Subsystem-API Too Large
[smell-description]When the API of a subsystem becomes too large in relation to the implementation, the main purpose of the subsystem is not served. A major part of the system will be visible to all other subsystems. Therefore, no significant complexity reduction has been achieved.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]OG
[smell-category]ARCH
[smell-name]Overgeneralization
[smell-description]In order to assure that subsystems provide the greatest extent of reusability, they must be flexibly applicable. This generalization can be overdone though, which will result in the subsystem’s overgeneralization.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]NL
[smell-category]ARCH
[smell-name]No Layers
[smell-description]Often layers are formed based on the large areas in which modification requirements emerge. If no layers exist, this kind of orientation aid is missing.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]URL
[smell-category]ARCH
[smell-name]Upward References between Layers
[smell-description]If a layer uses a higher located layer, the basic principle of layering has been ignored. Modifications of one layer cannot only have consequences for the higher layers, but also for those that are located further below.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]SLV
[smell-category]ARCH
[smell-name]Strict Layers Violated
[smell-description]It can always happen that a layer skips the one directly beneath it and accesses a layer further below instead, be it accidentally or on purpose. If layers that are basically strict are violated, their modifiability is affected. The number of a layer’s potential clients will increase, and the dependency between layers will grow.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]IPOL
[smell-category]ARCH
[smell-name]Inheritance between Protocol-Oriented Layers
[smell-description]Inheritance between protocol-oriented layers is not allowed. Otherwise a stricter than desirable coupling would occur. In particular it would become impossible to reimplement the layer that inherited in a non-object-oriented programming language later on.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]TML
[smell-category]ARCH
[smell-name]Too Many Layers
[smell-description]Too many layers in a system often cause too many indirections. One indication of unnecessary indirections are dumb delegations: one method simply invokes another method without implementing any functionality of its own.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]RVSL
[smell-category]ARCH
[smell-name]References between Vertically Separated Layers
[smell-description]References (regardless of which kind) between vertically separated layers create dependencies between layers. Thus the purpose of product lines can no longer be served.
[smell-ref]Lippert
[smell-end]

[smell]
[smell-id]CIM
[smell-category]CONFIG_D
[smell-name]Insufficient Modularization
[smell-description]An abstraction suffers from this smell when it is large or complex and thus can be modularized further. This smell arises in following forms: 1) if a file contains a declaration of more than one class or 'define', or 2) if the size of a class declaration is large crossing a certain threshold, or 3) the complexity of a class or 'define' is high.
[smell-aka]IM
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]MDC
[smell-category]CONFIG_I
[smell-name]Missing Default Case
[smell-description]A default case is missing in a 'case' or 'selector' statement.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]INC
[smell-category]CONFIG_I
[smell-name]Inconsistent Naming Convention
[smell-description]The used naming convention deviates from the recommended naming convention.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]CE
[smell-category]CONFIG_I
[smell-name]Complex Expression
[smell-description]A program contains a difficult to understand complex expression.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]DE2
[smell-category]CONFIG_I
[smell-name]Duplicate Entity
[smell-description]Duplicate hash keys or duplicate parameters present in the configuration code.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]MPA
[smell-category]CONFIG_I
[smell-name]Misplaced Attribute
[smell-description]Attribute placement within a resource or a class has not followed a recommended order (for example, mandatory attributes should be specified before the optional attributes).
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]IPA
[smell-category]CONFIG_I
[smell-name]Improper Alignment
[smell-description]The code is not properly aligned (such as all the arrows in a resource declaration) or tabulation characters are used.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]IPV
[smell-category]CONFIG_I
[smell-name]Invalid Property Value
[smell-description]An invalid value of a property or attribute is used (such as a file mode specified using 3-digit octal value rather than 4-digit).
[smell-ref]Tushar
[smell-end]


[smell]
[smell-id]IT
[smell-category]CONFIG_I
[smell-name]Incomplete Tasks
[smell-description]The code has 'fixme' and 'todo' tags indicating incomplete tasks.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]DSU
[smell-category]CONFIG_I
[smell-name]Deprecated Statement Usage
[smell-description]The configuration code uses one of the deprecated statements (such as 'import').
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]IQU
[smell-category]CONFIG_I
[smell-name]Improper Quote Usage
[smell-description]Single and double quotes are not used properly. For example, boolean values should not be quoted and variable names should not be used in single quoted strings.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]LS
[smell-category]CONFIG_I
[smell-name]Long Statement
[smell-description]The code contains long statements (that typically do not fit in a screen).
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]IC
[smell-category]CONFIG_I
[smell-name]Incomplete Conditional
[smell-description]An 'if..elsif' construct used without a terminating 'else' clause.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]UV
[smell-category]CONFIG_I
[smell-name]Unguarded Variable
[smell-description]A variable is not enclosed in braces when being interpolated in a string.
[smell-ref]Tushar
[smell-end]

[smell]
[smell-id]MAC
[smell-category]CONFIG_D
[smell-name]Multifaceted Abstraction
[smell-description]Each abstraction (e.g. a resource, class, 'define', or module) should be designed to specify the properties of a single piece of software. In other words, each abstraction should follow single responsibility principle. An abstraction suffers from multifaceted abstraction when the elements of the abstraction are not cohesive. \nThe smell may occur in the following two forms: 1) a resource (file, package, or service) declaration specifies attributes of more than one physical resources, or 2) all the language elements declared in a class, 'define', or a module are not cohesive.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]UAC
[smell-category]CONFIG_D
[smell-name]Unnecessary Abstraction
[smell-description]A class, 'define', or module must contain declarations or statements specifying the properties of a desired system. An empty class, 'define', or module shows the presence of unnecessary abstraction smell and thus must be removed.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]


[smell]
[smell-id]IAC
[smell-category]CONFIG_D
[smell-name]Imperative Abstraction
[smell-description]Puppet is declarative in nature. The presence of imperative statements (such as 'exec') defies the purpose of the language. An abstraction containing numerous imperative statements suffers from imperative abstraction smell.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]MAC2
[smell-category]CONFIG_D
[smell-name]Missing Abstraction
[smell-description]Resource declarations and statements are easy to use and reuse when they are encapsulated in an abstraction such as a class or 'define'. A module suffers from the missing abstraction smell when resources and language elements are declared and used without encapsulating them in an abstraction.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]DB
[smell-category]CONFIG_D
[smell-name]Duplicate Block
[smell-description]A duplicate block of statements more than a threshold indicates that probably a suitable abstraction definition is missing. Thus a module containing such a duplicate block suffers from duplicate block smell.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]CBH
[smell-category]CONFIG_D
[smell-name]Broken Hierarchy
[smell-description]The use of inheritance must be limited to the same module. The smell occurs when, the inheritance is used across namespaces where inheritance is not natural ('is-a' relationship is not followed).
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]UM
[smell-category]CONFIG_D
[smell-name]Unstructured Module
[smell-description]Each module in a configuration repository must have a well-defined and consistent module structure.  An ad-hoc structure of a repository suffers from unstructured module smell that impacts understandability and predictability of the repository.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]DS
[smell-category]CONFIG_D
[smell-name]Dense Structure
[smell-description]This smell arises when a configuration code repository has excessive and dense dependencies without any particular structure.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]CDE
[smell-category]CONFIG_D
[smell-name]Deficient Encapsulation
[smell-description]This smell arises when a node definition or ENC (External Node Classifier) declares a set of global variables to be picked up by the included classes in the definition.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]CWM
[smell-category]CONFIG_D
[smell-name]Weakened Modularity
[smell-description]Each module must strive for high cohesion and low coupling. This smell arises when a module exhibits high coupling and low cohesion.
[smell-ref]Tushar
[smell-tool]PUPPETEER
[smell-end]

[smell]
[smell-id]GF
[smell-category]TEST
[smell-name]General Fixture
[smell-description]The general fixture smell occurs if test classes contain broad functionality in the implicit setup, and different tests only access part of the fixture. \nProblems caused by a general fixture are two-fold: firstly, the cause-effect relationship between fixture and the expected outcome is less visible, and tests are harder to read and understand. This can cause tests to be fragile: a change that should be unrelated affects tests because too much functionality is covered in the fixture. Secondly, the test execution performance can deteriorate, and test execution times may eventually lead to developers avoiding to execute tests.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]TM
[smell-category]TEST
[smell-name]Test Maverick
[smell-description]A test method is a maverick when the class comprising the test method contains an implicit setup, but the test method is completely independent from the implicit setup procedure. The setup procedure will be executed before the test method is executed, but it is not needed.
[smell-ref]Michaela
[smell-end]


[smell]
[smell-id]DF
[smell-category]TEST
[smell-name]Dead Fields
[smell-description]The dead field smell occurs when a class or its super classes have fields that are never used by any test method. Often dead fields are inherited. This can indicate a non-optimal inheritance structure, or that the super class conflicts with the single responsibility principle. Also, dead fields within the test class itself can indicate incomplete or deprecated development activities.
[smell-ref]Michaela
[smell-end]

[smell]
[smell-id]LCTM
[smell-category]TEST
[smell-name]Lack of Cohesion of Test Methods
[smell-description]The smell Lack of Cohesion of test methods occurs if test methods are grouped together in one test class, but they are not cohesive.
[smell-ref]Michaela
[smell-end]

[smell]
[smell-id]OILS
[smell-category]TEST
[smell-name]Obscure In-Line Setup
[smell-description]An in-line setup should consist of only the steps and values essential to understanding the test. Essential but irrelevant steps should be encapsulated into helper methods. An obscure in-line setup covers too much setup functionality within the test method. This can hinder developers in seeing the relevant verification steps of the test.
[smell-ref]Michaela
[smell-end]

[smell]
[smell-id]VHS
[smell-category]TEST
[smell-name]Vague Header Setup
[smell-description]A vague header setup smell occurs when fields are initialized in the header of a class, but not in implicit setup. It is a smell as the behavior of the code is not explicitly defined, and depends on the field modifier (static or member), as well as on the implementation of the test framework. Further, field declarations are not restricted to the header of a class, but can occur anywhere within the class. Vague header setups hamper code comprehension and maintainability.
[smell-ref]Michaela
[smell-end]

[smell]
[smell-id]MG
[smell-category]TEST
[smell-name]Mystery Guest
[smell-description]When a test uses external resources, such as a file containing test data, the test is no longer self contained. Consequently, there is not enough information to understand the tested functionality, making it hard to use that test as documentation
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]RO
[smell-category]TEST
[smell-name]Resource Optimism
[smell-description]Test code that makes optimistic assumptions about the existence (or absence) and state of external resources (such as particular directories or database tables) can cause non-deterministic behavior in test outcomes.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]TRW
[smell-category]TEST
[smell-name]Test Run War
[smell-description]Such wars arise when the tests run fine as long as you are the only one testing but fail when more programmers run them. This is most likely caused by resource interference: some tests in your suite allocate resources such as temporary files that are also used by others.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]ET
[smell-category]TEST
[smell-name]Eager Test
[smell-description]When a test method checks several methods of the object to be tested, it is hard to read and understand, and therefore more difficult to use as documentation. Moreover, it makes tests more dependent on each other and harder to maintain.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]LT
[smell-category]TEST
[smell-name]Lazy Test
[smell-description]This occurs when several test methods check the same method using the same fixture (but for example check the values of different instance variables).
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]AR
[smell-category]TEST
[smell-name]Assertion Roulette
[smell-description]"Guess what’s wrong?" This smell comes from having a number of assertions in a test method that have no explanation. If one of the assertions fails, you do not know which one it is.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]TIT
[smell-category]TEST
[smell-name]Indirect Testing
[smell-description]A test class is supposed to test its counterpart in the production code. It starts to smell when a test class contains methods that actually perform tests on other objects (for example because there are references to them in the class-to-be-tested).
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]FTO
[smell-category]TEST
[smell-name]For Testers Only
[smell-description]When a production class contains methods that are only used by test methods, these methods either (1) are not needed and can be removed, or (2) are only needed to set up a fixture for testing.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]TCD
[smell-category]TEST
[smell-name]Test Code Duplication
[smell-description]Test code may contain undesirable duplication. In particular the parts that set up test fixtures are susceptible to this problem.
[smell-ref]Arie
[smell-end]

[smell]
[smell-id]ACE
[smell-category]ARCH
[smell-name]Connector Envy
[smell-description]Connectors provide communication, coordination, conversion, and facilitation. This smell occurs when components encompass extensive interaction-related functionality that should be delegated to a connector.
[smell-ref]Joshua
[smell-end]

[smell]
[smell-id]SPF
[smell-category]ARCH
[smell-name]Scattered Parasitic Functionality
[smell-description]Scattered Parasitic Functionality describes a system where multiple components are responsible for realizing the same high-level concern and, additionally, some of those components are responsible for orthogonal concerns. This smell violates the principle of separation of concerns.
[smell-ref]Joshua
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]AAI
[smell-category]ARCH
[smell-name]Ambiguous Interfaces
[smell-description]Ambiguous Interfaces are interfaces that offer only a single, general entry-point into a component. This smell appears especially in event-based publish-subscribe systems, where interactions are not explicitly modeled and multiple components exchange event messages via a shared event bus.
[smell-ref]Joshua
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]EAC
[smell-category]ARCH
[smell-name]Extraneous Adjacent Connector
[smell-description]The Extraneous Adjacent Connector smell occurs when two connectors of different types are used to link a pair of components.
[smell-ref]Joshua
[smell-end]

[smell]
[smell-id]AFC
[smell-category]ARCH
[smell-name]Feature Concentration
[smell-description]A component suffers from the feature concentration architecture smell when one architectural component realizes more than one architecture concern.
[smell-ref]Hugo
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]AUD
[smell-category]ARCH
[smell-name]Unstable Dependency
[smell-description]Stable Abstractions principle states that components that are maximally stable should be maximally abstract and unstable components must be concrete. Unstable dependency architecture smell arises in a component when the component depends on a less stable component.
[smell-ref]Fontana
[smell-tool]DESIGNITE
[smell-end]


[smell]
[smell-id]DCA
[smell-category]DBase
[smell-name]Compound Attribute
[smell-description]This smell arises when a column is used to store a non-atomic attribute. For instance, storing comma-separated lists for an attribute to avoid creating an intersection table for a many-to-many relationship or storing a JSON file which is not used atomically. \nEach attribute value must be stored and retrieved atomically. If a table does not adhere to this practice, the resultant schema introduces multiple problems. For instance, a user has to write more complex queries (using pattern-matching expressions) to retrieve data from this table. Such complex queries are prone to inaccurate results. Also, such queries cannot exploit available indexes. Even further, these queries are not portable due to vendor specific support to pattern-matching expressions.
[smell-example]CREATE TABLE Books (\nbook_id SERIAL PRIMARY KEY,\nbook_title VARCHAR (1000),\nauthors VARCHAR (1000), -- comma-separated list \n--, , ,\n};
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]

[smell]
[smell-id]DAL
[smell-category]DBase
[smell-name]Adjacency List
[smell-description]The smell occurs when an attribute in a table refers another row in the same table i.e., a table has a recursive relationship to model hierarchical structure. \nQuerying a tree with adjacency list is quite difficult and error-prone. Specifically, deleting a node from a tree which is modelled using adjacency list is non-trivial and prone to introduce errors in the database.
[smell-example]CREATE TABLE Comments (\ncomment_id SERIAL PRIMARY KEY,\nparent_id BIGINT UNSIGNED,\n-- ,  ,  ,\nFOREIGN KEY (parent_id) REFERENCES Comments (comment_id),\n--, , ,\n};
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]

[smell]
[smell-id]DSK
[smell-category]DBase
[smell-name]Superfluous Key
[smell-description]This smell arises when an unnecessary superfluous pseudo key is defined in a table where other attribute(s) in the table may serve as a primary key. \nChoosing an appropriate primary key is an essential requirement for a table. A pseudo key could be defined when the present set of attributes could not serve as a primary key. However, a pseudo key is unnecessary and even erroneous (leads to duplicate rows) when the existing set of attributes of the table could be used as a primary key.
[smell-example]CREATE TABLE BugsProducts (\nid SERIAL PRIMARY KEY,\nbug_id BIGINT UNSIGNED NOT NULL,\nproduct_id BIGINT UNSIGNED NOT NULL,\nUNIQUE KEY (bug_id, product_id),\n-- ,  ,  ,\n};
[smell-ref]Karwin
[smell-end]

[smell]
[smell-id]DMC
[smell-category]DBase
[smell-name]Missing Constraint
[smell-description]This smell arises when constraints for a foreign key are missing from a schema definition. \nReferential integrity is an essential property of relational databases. Values referenced in a foreign key column must exist in the columns of primary or unique keys of the parent table. It can be easily achieved by defining constraints on foreign keys. However, when such constraints are missing for a foreign key it leads to compromized referential integrity of the database.
[smell-example]CREATE TABLE BugsProducts (\nid SERIAL PRIMARY KEY,\nbug_id BIGINT UNSIGNED NOT NULL,\nproduct_id BIGINT UNSIGNED NOT NULL,\nUNIQUE KEY (bug_id, product_id),\n-- No foreign key constraints for bug_id and product_id\n};
[smell-ref]Karwin
[smell-end]

[smell]
[smell-id]DMD
[smell-category]DBase
[smell-name]Metadata as Data
[smell-description]This smell occurs when metadata is stored as data in the form of EAV (Entity-Attribute-Value) pattern.\nIn a relational table, all the attributes are equally applicable for all the rows in the table. It is tempting to implement EAV pattern when a subset of attributes applicable for a subset of rows and the rest of attributes for rest of the rows. However, this arrangement introduces many deficiencies in the database; for example, one can't use native SQL data types (leading to invalid data), one can't enforce referential integrity, and one can't make up attribute names.
[smell-example]CREATE TABLE IssueAttributes (\nissue_id    BIGINT UNSIGNED NOT NULL,\nattr_name   VARCHAR(100) NOT NULL,\nattr_value  VARCHAR(100),\nPRIMARY KEY (issue_id, attr_name),\nFOREIGN KEY (issue_id) REFERENCES Issues(issue_id)\n);
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]

[smell]
[smell-id]DPA
[smell-category]DBase
[smell-name]Polymorphic Association
[smell-description]This smell occurs when a table uses a multi-purpose foreign key.\nRelational database schema does not allow us to declare polymorphic association. However, many times developers define an additional column in a table as a tag to realize a polymorphic association. This arrangement makes it difficult to query the table and compromises readability and understandability.
[smell-example]CREATE TABLE Comments ( \ncomment_id SERIAL PRIMARY KEY,\nissue_type VARCHAR(20),     -- "Bugs" or "FeatureRequests"\nissue_id BIGINT UNSIGNED NOT NULL,\nauthor BIGINT UNSIGNED NOT NULL,\ncomment_date DATETIME,\ncomment TEXT,\nFOREIGN KEY (author) REFERENCES Accounts(account_id)\n);
[smell-ref]Karwin
[smell-end]

[smell]
[smell-id]DMA
[smell-category]DBase
[smell-name]Multicolumn Attribute
[smell-description]This smell arises when multiple serial columns are created for an attribute.\nIn cases when an attribute may have one or more values, it is tempting to create multiple columns for the attribute in a table. However, such a schema design makes querying the table very difficult and verbose.
[smell-example]CREATE TABLE Bugs (\nbug_id SERIAL PRIMARY KEY,\ndescription VARCHAR(1000),\ntag1 VARCHAR(20),\ntag2 VARCHAR(20),\ntag3 VARCHAR(20)\n);
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]


[smell]
[smell-id]DCT
[smell-category]DBase
[smell-name]Clone Tables
[smell-description]This smell occurs when a table is split horizontally in multiple tables using some criterion (for example, year) to achieve scalability.\nThis smell not only makes the querying difficult but also introduces problems managing data integrity.
[smell-example]CREATE TABLE Bugs_2008 ( . . . );\nCREATE TABLE Bugs_2009 ( . . . );\nCREATE TABLE Bugs_2010 ( . . . );
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]

[smell]
[smell-id]DVAD
[smell-category]DBase
[smell-name]Values in Attribute Definition
[smell-description]This smell arises when specific values are defined in an attribute definition to restrict possible values of the attribute.\nSpecifying all possible values for an attribute in schema definition mixes metadata with data which is not recommended. This smell makes it difficult to extend or modify the list of accepted values for an attribute.
[smell-example]CREATE TABLE Bugs (\n-- other columns\nstatus VARCHAR(20) CHECK (status IN ('NEW', 'IN PROGRESS', 'FIXED'))\n);
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]


[smell]
[smell-id]DIA
[smell-category]DBase
[smell-name]Index Abuse
[smell-description]This smell arises when the indexes are used poorly. This smell has the following variants: 1) Missing indexes, 2) Insufficient indexes, and 3) Unused indexes.\nCreating effective indexes is not trivial; it requires judicious planning. A database with a deficient plan for indexes performs poorly.
[smell-ref]Karwin
[smell-tool]DBDEO
[smell-end]


[smell]
[smell-id]DGT
[smell-category]DBase
[smell-name]God Table
[smell-description]This smell arises when a table contains excessive number of attributes.\nExcessive number of attributes tend to violate the principles of normalization which in turn introduce a variety of problems. Additionally, it impacts maintainability of the database.
[smell-example]CREATE TABLE bet_matches( id TEXT PRIMARY KEY, tx0_index INTEGER, tx0_hash TEXT, tx0_address TEXT, tx1_index INTEGER, tx1_hash TEXT, tx1_address TEXT, tx0_bet_type INTEGER, tx1_bet_type INTEGER, feed_address TEXT, initial_value INTEGER, deadline INTEGER, target_value REAL, leverage INTEGER, forward_quantity INTEGER, backward_quantity INTEGER, tx0_block_index INTEGER, tx1_block_index INTEGER, block_index INTEGER, tx0_expiration INTEGER, tx1_expiration INTEGER, match_expire_index INTEGER, fee_fraction_int INTEGER, status TEXT, FOREIGN KEY (tx0_index, tx0_hash, tx0_block_index) REFERENCES transactions(tx_index, tx_hash, block_index), FOREIGN KEY (tx1_index, tx1_hash, tx1_block_index) REFERENCES transactions(tx_index, tx_hash, block_index));
[smell-ref]Redgate
[smell-tool]DBDEO
[smell-end]


[smell]
[smell-id]DMN
[smell-category]DBase
[smell-name]Meaningless Name
[smell-description]This smell occurs when a table or an attribute name is cryptic or meaningless.\nMeaningless or cryptic names hamper readability of the database's schema.
[smell-example]CREATE TABLE master ( \nid TEXT PRIMARY KEY, \ntx0 INTEGER, \ntx1 TEXT,\n-- other attributes\n);
[smell-ref]Redgate
[smell-end]

[smell]
[smell-id]DOA
[smell-category]DBase
[smell-name]Overloaded Attribute Names
[smell-description]This smell occurs when two or more attributes are defined with identical names but as distinct data types in different tables.\nIdentical names with different data types create confusion and could lead to subtle bugs in queries.
[smell-example]CREATE TABLE `spell_override` (\n`comment` LONGTEXT NOT NULL,\n-- other columns\n);\nCREATE TABLE `creature_text` (\n`comment` varchar(255) DEFAULT, -- overloaded attribute\n-- other columns\n);
[smell-ref]Redgate
[smell-tool]DBDEO
[smell-end]

[smell]
[smell-id]SMO
[smell-category]SPREADSHEET
[smell-name]Multiple Operations
[smell-description]Analogous to a long method, a formula with many different operations will likely be harder to understand than a shorter one. Especially since in most spreadsheet programs, there is limited space to view a formula, causing long formulas to be cut off.
[smell-aka]LM
[smell-ref]Felienne2012
[smell-end]

[smell]
[smell-id]SMR
[smell-category]SPREADSHEET
[smell-name]Multiple References
[smell-description]The formula equivalent of this smell occurs when a formula references many different other cells. Locating the different cells that are contained in a formula can be challenging.
[smell-ref]Felienne2012
[smell-aka]LPL
[smell-end]

[smell]
[smell-id]SCC
[smell-category]SPREADSHEET
[smell-name]Conditional Complexity
[smell-description]A formula with many conditional operations is considered smelly. Many conditional branches make a formula hard to read and understand.
[smell-ref]Felienne2012
[smell-end]

[smell]
[smell-id]SLCC
[smell-category]SPREADSHEET
[smell-name]Long Calculation Chain
[smell-description]Spreadsheet formulas can refer to each other, hence creating chains of calculation. To understand the meaning of such a formula, a spreadsheet user has to trace along multiple steps to find the origin of the data. To lower the number of steps of a calculation chain, steps of the chain could be merged into one cell.
[smell-ref]Felienne2012
[smell-end]

[smell]
[smell-id]SDF
[smell-category]SPREADSHEET
[smell-name]Duplicated Formulas
[smell-description]This smell occurs where some formulas are partly the same as others. Consider, for example, a worksheet that contains a cell with formula SUM(A1:A6)+10% and a second formula SUM(A1:A6)+20%. This formula exhibits duplication; the part SUM(A1:A6) is contained in more than one formula. Such a duplication impacts maintainainability and readability.
[smell-ref]Felienne2012
[smell-end]

[smell]
[smell-id]SII
[smell-category]SPREADSHEET
[smell-name]Inappropriate Intimacy
[smell-description]This smell occurs when a worksheet overly related to another worksheet. This is possibly unhealthy for several reasons. First, adapting one sheet likely requires inspecting the other worksheet, requiring the spreadsheet user to switch back and forth between the two worksheets, increasing the chance that errors are made. Secondly, since there is a strong semantic connection between the two worksheets, the fact that they are split could influence understandability.
[smell-aka]II
[smell-ref]Felienne2012b
[smell-end]


[smell]
[smell-id]SFE
[smell-category]SPREADSHEET
[smell-name]Feature Envy
[smell-description]This smell occurs when there is a formula that is more interested in cells from another worksheet. In such a case, it would be better to move the formula to that worksheet. This will likely improve understandability, since the formula is then closer to the cells it is referring to.
[smell-aka]FE
[smell-ref]Felienne2012b
[smell-end]

[smell]
[smell-id]SMM
[smell-category]SPREADSHEET
[smell-name]Middle Man
[smell-description]This smell arises in worksheets where 'middle man' formulas occur, that contains only a reference to another cell and calculations, like the formula '=Sheet1!A2.' A worksheet suffering from the Middle Man smell could complicate the structure of a spreadsheet, and therefore reduces spreadsheet quality.
[smell-aka]MM
[smell-ref]Felienne2012b
[smell-end]

[smell]
[smell-id]SSS
[smell-category]SPREADSHEET
[smell-name]Shotgun Surgery
[smell-description]This smell occurs due to a formula F that is referred to by many different formulas in different worksheets. The chances are high that many of the formulas that refer to F will have to be changed if F is changed. Shotgun Surgery could have an impact on the maintainability of a spreadsheet, since it requires the user to make a number of changes when F is changed.
[smell-aka]SS
[smell-ref]Felienne2012b
[smell-end]

[smell]
[smell-id]PTH
[smell-category]PRESENTATION
[smell-name]Text Hell
[smell-description]A presentation is not a document nor a teleprompter; hence, don’t try to stuff all the information in words. If a slide contains a lot of text, your audience will try to read the text and will not bother what you are speaking. Slides are for defining the flow and providing visual information such as images and videos; thus, use it in the spirit and not otherwise.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PCM
[smell-category]PRESENTATION
[smell-name]Color-mania
[smell-description]Slide design is not a competition where slides with maximum colors used will win. A human mind takes some time to identify and process the colors; therefore, simplify your slides and avoid multicolor text so that the audience pay attention to content and not to the colors. Use preferably one (or maximum two) colors for the text in a slide and use them consistently throughout your presentation. Also, pay attention to the background color and contrast; avoid multicolor background and make sure that foreground color of your slides is contrasting with slide’s background color.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PBB
[smell-category]PRESENTATION
[smell-name]Brother of the Bride
[smell-description]In many cultures, brother of the bride has many responsibilities at the time of his sister’s marriage. Don’t make your slides look like such a brother. In other words, follow single responsibility principle and put one concept, idea, or thought in a slide.
[smell-ref]TusharPPT
[smell-end]

[smell]
[smell-id]PBYOB
[smell-category]PRESENTATION
[smell-name]BYOB (Bring Your Own Binocular)
[smell-description]The text (or image) that you put on your slides must be readable from the back of the room where you are going to present. The audience does not carry binoculars; thus, you must not pretend the same.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]


[smell]
[smell-id]PHIPU
[smell-category]PRESENTATION
[smell-name]HiPU (Highly Paid but Useless) Headers
[smell-description]Headers get the highest attention because of their size. In many situations, slide headers are verbose and do not convey additional useful information. Avoid headers in such cases, or reduce their size.
[smell-ref]TusharPPT
[smell-end]

[smell]
[smell-id]PSP
[smell-category]PRESENTATION
[smell-name]Secretary of HiPU
[smell-description]A line under the slide headers is analogous to a secretary of HiPU. Do not underline the slide header. It populates the slide with unnecessary noise. In fact, underlines must be avoided not only in headers but also in the body text.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PDYK
[smell-category]PRESENTATION
[smell-name]Do You Know Who I Am
[smell-description]The title slide may contain affiliation about the contributors and presenter; however, repeating this information (in the form of university/company name or logo) at the bottom (or top) of every slide is unnecessary and annoying.
[smell-ref]TusharPPT
[smell-end]

[smell]
[smell-id]PBBB
[smell-category]PRESENTATION
[smell-name]Bullet, [sub-]bullet, [sub-sub-]bullet
[smell-description]One level of bullets in a slide is preferred. Use the second level of bullets only when it is really necessary. Third-level bullets must be avoided.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PLV
[smell-category]PRESENTATION
[smell-name]It’s Las Vegas
[smell-description]Animations must be used only where they make sense. Over usage of animations with a lot of moving objects distract the audience and thus, must be avoided.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PCS
[smell-category]PRESENTATION
[smell-name]Chaotic Stylist
[smell-description]All the slides in a presentation must follow a single style consistently. The style includes text size and color for both body text and headers, color, width, and drawing pattern of shapes, and border style and shadow of image objects. Inconsistency shows recklessness of the presenter and thus, must be avoided.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]

[smell]
[smell-id]PSS
[smell-category]PRESENTATION
[smell-name]Stung by Spell-bee
[smell-description]Making a spelling mistake is analogous to committing a crime. Spell-checkers are available on each presentation preparing software, so there is no excuse for making spelling mistakes. Each presentation must go through a spell-checker to avoid unnecessary embarrassment.
[smell-ref]TusharPPT
[smell-tool]SLIDEQ
[smell-end]


[smell]
[smell-id]PDD
[smell-category]PRESENTATION
[smell-name]The Devil of Details
[smell-description]Do not try to explain the nitty-gritty of your method or idea in a short presentation. Often, the short time is not enough to allow the presenter to go in the details. An attempt to quickly cover the details will result in the losing attention of the audience. Abstract the idea, simply complex figures, and use metaphors to communicate your ideas effectively.
[smell-ref]TusharPPT
[smell-end]

[smell]
[smell-id]EPV
[smell-category]ENERGY
[smell-name]Parameter By Value
[smell-description]This smell occurs when a parameter is passed by value to a function. Passed by value parameters consume more memory and wastes CPU-time by copying the value of the data structure at its original location to the new location.
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]ESA
[smell-category]ENERGY
[smell-name]Self Assignment
[smell-description]This smell occurs when a variable is assigned to itself (e.g., x=x).
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]EME
[smell-category]ENERGY
[smell-name]Mutual Exclusion OR
[smell-description]This smell occurs when an OR operator is used between two mutually exclusive conditions (thus always evaluating to true).
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]EDLS
[smell-category]ENERGY
[smell-name]Dead Local Store
[smell-description]This smell occurs when a statement assigns a value to a local variable which is not used in any subsequent instruction. A variant of the smell occurs when a return statement assigns a value to a local variable which is not used in any subsequent instruction. (i.e. return(x=1); )
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]ESRA
[smell-category]ENERGY
[smell-name]Switch Redundant Assignment
[smell-description]This smell occurs when a redundant assignment is made in a switch statement: for example, assigning a value to a variable in a case block without a following break instruction, then re-assigning another value to the same variable in the subsequent case block.
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]ERC
[smell-category]ENERGY
[smell-name]Repeated Conditionals
[smell-description]This smell occurs when a condition is evaluated twice (e.g., x==0 -- x==0).
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]ENSC
[smell-category]ENERGY
[smell-name]Non Short Circuit Operators
[smell-description]Code using non-short-circuit logic boolean operators (e.g., & or ∥) rather than short-circuit logic ones (&& or ∥∥). Non-short-circuit logic causes both sides of the expression to be evaluated even when the result can be inferred from knowing the left-hand side.
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]EUCF
[smell-category]ENERGY
[smell-name]Useless Control Flow
[smell-description]Control flow constructs which do not modify the flow of the program, regardless of whether or not the branch is taken (e.g., an if statement with an empty body).
[smell-ref]Antonio
[smell-end]

[smell]
[smell-id]PGC
[smell-category]PERFORMANCE
[smell-name]God Class
[smell-description]From a performance perspective, a “god” class creates problems by causing excessive message traffic. In the behavioral form of the problem, the excessive traffic occurs as the “god” class requests and updates the data it needs to control the system from subordinate classes. In the data form, the problem is reversed as subordinates request and update data in the “god” class. In both cases, the number of messages required to perform a function is larger than it would be in a design that assigned related data and behavior to the same class.
[smell-ref]Smith
[smell-aka]GC
[smell-end]


[smell]
[smell-id]PEDA
[smell-category]PERFORMANCE
[smell-name]Excessive Dynamic Allocation
[smell-description]Dynamic allocation is expensive. When an object is created, the memory to contain it (and any objects that it contains) must be allocated from the heap and any initialization code for the object and the contained objects must be executed. When the object is no longer needed, necessary clean-up must be performed and the reclaimed memory must be returned to the heap to avoid “memory leaks.” While the overhead for creating and destroying a single object may be small, when a large number of objects are frequently created and then destroyed, the performance impact may be significant.
[smell-ref]Smith
[smell-end]

[smell]
[smell-id]PCTH
[smell-category]PERFORMANCE
[smell-name]Circuitous Treasure Hunt
[smell-description]Software retrieves data from a first table, uses those results to search a second table, retrieves data from that table, and so on until the “ultimate results” are obtained. The impact on performance is the large amount of database processing required each time the “ultimate results” are needed. It is especially problematic when the data is on a remote server and each access requires transmitting all the intermediate queries and their results via a network and perhaps through other servers in a multi-tier environment.
[smell-ref]Smith
[smell-end]

[smell]
[smell-id]POLB
[smell-category]PERFORMANCE
[smell-name]The One Lane Bridge
[smell-description]One Lane Bridge is a point in the execution where one, or only a few, processes may continue to execute concurrently. All other processes must wait. It frequently occurs in applications that access a database. Here, a lock ensures that only one process may update the associated portion of the database at a time. It may also occur when a set of processes make a synchronous call to another process that is not multi-threaded; all of the processes making synchronous calls must take turns “crossing the bridge.”
[smell-ref]Smith
[smell-end]

[smell]
[smell-id]UINT
[smell-category]ARCH
[smell-name]Unstable Interface
[smell-description]A file with many incoming dependencies (the interface) that changes frequently with other files.
[smell-ref]Mo
[smell-end]

[smell]
[smell-id]CROSSM
[smell-category]ARCH
[smell-name]Implicit Cross-Module Dependency
[smell-description]Two structurally independent modules nonetheless have co-change relationships in the revision log.
[smell-ref]Mo
[smell-end]

[smell]
[smell-id]UNINHERIT
[smell-category]DESIGN
[smell-name]Unhealthy Inheritance Hierarchy
[smell-description]A parent class that depends on its children, or a client class depending on both parent and child.
[smell-ref]Mo
[smell-end]

[smell]
[smell-id]CMC
[smell-category]ARCH
[smell-name]Cross-module Cycle
[smell-description]A dependency cycle that crosses module boundaries.
[smell-aka]DCP
[smell-ref]Mo
[smell-tool]DESIGNITE
[smell-end]

[smell]
[smell-id]PFD
[smell-category]PERFORMANCE
[smell-name]Falling Dominoes
[smell-description]This smell occurs when one failure causes performance failures in other components.\nSolution: Make sure that broken pieces are isolated until they are repaired.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PEST
[smell-category]PERFORMANCE
[smell-name]Empty Semi Trucks
[smell-description]This smell occurs when an excessive number of requests is required to perform a task. It may be due to inefficient use of available bandwidth, an inefficient interface, or both.\nSolution: The Batching performance pattern combines items into messages to make better use of available bandwidth. The Coupling performance pattern, Session Facade design pattern, and Aggregate Entity design pattern provide more efficient interfaces.
[smell-ref]Smith03
[smell-aka]PRT
[smell-end]

[smell]
[smell-id]PRT
[smell-category]PERFORMANCE
[smell-name]Roundtripping
[smell-description]This smell is a special case of Empty Semi Trucks. It occurs when many fields in a user interface must be retrieved from a remote system.\nSolution: Buffer all the calls together and make them in one trip. The Facade design pattern and the distributed command bean accomplish this buffering.
[smell-aka]PEST
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PTB
[smell-category]PERFORMANCE
[smell-name]Tower of Babel
[smell-description]This smell occurs when processes excessively convert, parse, and translate internal data into a common exchange format such as XML.\nSolution: he Fast Path performance pattern identifies paths that should be stream-lined. Minimize the conversion, parsing, and translation on those paths by using the Coupling performance pattern to match the data format to the usage patterns.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PUP
[smell-category]PERFORMANCE
[smell-name]Unbalanced Processing
[smell-description]This smell occurs when processing cannot make use of available processors, the slowest filter in a “pipe and filter” architecture causes the system to have unacceptable throughput, or when extensive processing in general impedes overall response time.\nSolution: 1) Restructure software or change scheduling algorithms to enable concurrent execution. 2) Break large filters into more stages and combine very small ones to reduce overhead. 3) Move extensive processing so that it doesn’t impede high traffic or more important work.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PUNP
[smell-category]PERFORMANCE
[smell-name]Unnecessary Processing
[smell-description]This smell occurs when processing is not needed or not needed at that time.\nSolution: Delete the extra processing steps, reorder steps to detect unnecessary steps earlier, or restructure to delegate those steps to a background task.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PTR
[smell-category]PERFORMANCE
[smell-name]The Ramp
[smell-description]This smell occurs when processing time increases as the system is used.\nSolution: Select algorithms or data structures based on maximum size or use algorithms that adapt to the size.
[smell-ref]Smith03
[smell-aka]PSDR
[smell-end]

[smell]
[smell-id]PSDR
[smell-category]PERFORMANCE
[smell-name]Sisyphus Database Retrieval
[smell-description]It is a special case of The Ramp. This smell occurs when performing repeated queries that need only a subset of the results.\nSolution:Use advanced search techniques that only return the needed subset.
[smell-aka]PTR
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PML
[smell-category]PERFORMANCE
[smell-name]More is Less
[smell-description]This smell occurs when a system spends more time “thrashing” than accomplishing real work because there are too many processes relative to available resources.\nSolution: Quantify the thresholds where thrashing occurs (using models or measurements) and determine if the architecture can meet its performance goals while staying below the threshholds.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]PTJ
[smell-category]PERFORMANCE
[smell-name]Traffic Jam
[smell-description]This smell occurs when one problem causes a backlog of jobs that produces wide variability in response time which persists long after the problem has disappeared.\nSolution: Begin by eliminating the original cause of the backlog. If this is not possible, provide sufficient processing power to handle the worst-case load.
[smell-ref]Smith03
[smell-end]

[smell]
[smell-id]GCM
[smell-category]CONVENTION
[smell-name]Misformat
[smell-description]There are many formatting mistakes one can make when creating a grammar without proper tool support. Mostly they revolve around mistypings, misspellings, misalignments, etc, and result in actual incorrect constructs in extracted grammars.
[smell-aka]GXTN
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GCMN
[smell-category]CONVENTION
[smell-name]Misnomer
[smell-description]There are a lot of potential problems with names used within a grammar, mostly concerning nonterminal names and labels. One can blame names to be uncommunicative such as abc or pqr are much worse for the readability and maintainability of the grammar than if_statement, CompilationUnit or DIGIT, similarly to how this is a problem in programming in general. Also, names can be misleading and contain words that contradict the definition of the named entity.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GCS
[smell-category]CONVENTION
[smell-name]SayMyName
[smell-description]In small grammars misspellings and misnamings are easy to overlook since humans are naturally capable of that. When the grammar size increases, primitive automation techniques are used like plain text search, and such a search query looking for all statements will not find the one labelled with “staetment”.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GCZ
[smell-category]CONVENTION
[smell-name]ZigZag
[smell-description]ZigZag was a previously identified micropattern of a non- terminal de ned in a style that mixes horizontal production rules (the ones with a top-level choice) with vertical production rules (with several rules per nonterminal).
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GCSP
[smell-category]CONVENTION
[smell-name]Splat
[smell-description]Since definitions of vertical nonterminals consist of several production rules, these rules can be distributed over the grammar and not focused in one place. This may be bad, especially if most of the rules are collected together, and only one or two are elsewhere.
[smell-aka]GCZ
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNU
[smell-category]NOTATION
[smell-name]Underuse
[smell-description]The original BNF used for early ALGOL, did not yet borrow Kleene star (x* for zero or more xs) and Kleene cross (x+ for one or more) from regular expressions, and early parser specification notations were just as limited. Grammars written with those notations in mind (not necessarily for using them!), suffer from “yaccification”, when all repetitions are written out explicitly as additional left-recursive nonterminals. This pattern is well-known to be harmful since it reduces grammar’s both readability (being basically an encoding move, not a modelling one) and portability (a left-recursive grammar is often useless or suboptimal for top-down parsing).
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNO
[smell-category]NOTATION
[smell-name]Overspec
[smell-description]In many notations, there are various ways to achieve the same effect, and information in those should not be duplicated or contradictory, since it only confuses grammar engineers and leads to grammars with very subtle bugs.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNP
[smell-category]NOTATION
[smell-name]Priorities
[smell-description]A typical layered grammar treats highly recursive language constructs with sophisticated priorities by explicitly encoding them in a long streak of nonterminals. A cleaner way would have been to merge all definitions into one nonterminal (or a few conceptually grouped ones) and to define priorities between them.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNS
[smell-category]NOTATION
[smell-name]Singleton
[smell-description]The designers of grammar notations, as all DSL designers, try to make them  t the domain, but never achieve absolute perfection. In particular, multiary symbols with arity of 2 and up, are commonly expressed in such a way that allows their use on an empty or trivial list of arguments.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNC
[smell-category]NOTATION
[smell-name]Combo
[smell-description]Grammar combinators (metasymbols of arity 1 and up) such as the Kleene star and cross, or an optional, can be combined in an improper way. For example, a grammar engineer who defines A ::= B?; and B ::= C?;, may mean well, but creates a confusing contract if A is used to bind a textual structure with a tree structure: it is ambiguous what an empty string corresponds to—an empty node A or a node A containing an empty node B.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNCH
[smell-category]NOTATION
[smell-name]Chant
[smell-description]Nonterminals smell that were “defined” in natural language instead of the actual grammar notation: “defined similarly to...”, “all Unicode characters of class...”, “any of the following”, etc. These are drastic examples of this smell, since they make the grammar completely useless for automatic machine consumption, and require a human expert to either fix the grammar or devise a semiparsing workaround, and possibly an extra person to translate the description to a natural language understandable by the expert.
[smell-aka]GSHDE
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GND
[smell-category]NOTATION
[smell-name]Deprecated
[smell-description]Similarly to deprecated statements and methods in program- ming, grammar notations may have some functionality that is no longer considered viable and proper in the new version.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GNE
[smell-category]NOTATION
[smell-name]Exotic
[smell-description]This smell is in contradiction with Underuse, and states that using notational features that are uncommon, obscure or overly exotic, should be limited. Excessive use of features idiosyncratic for one particular notation, will result in a vendor lock-in. For example, if a notation allows context handling (pushing the grammar outside the comfort zone of CFGs), using it is only fully justified when the result is too cumbersome otherwise.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPF
[smell-category]PARSING
[smell-name]Factoring
[smell-description]In classic by-the-book non-memoising parsing, if alternative production rules from the same nonterminal start from the same symbols, these would have to be reparsed in each of the branches. As a real example:\nopen_if_statement\n: IF boolean_expression THEN statement\n| IF boolean_expression THEN closed_statement\nELSE open_statement;\nInterestingly, this example is a false positive: factoring the first three symbols into a separate nonterminal will clutter the grammar without bringing any noticeable benefits (and will introduce the Weak smell).
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPS
[smell-category]PARSING
[smell-name]1SidedRecursion
[smell-description]It is well-known that left-recursive definitions are deadly for by-the-book top-down parsing technologies, since they create an infinite loop and cause the parser to crash from stack overflow.
[smell-aka]GXTRE
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPSU
[smell-category]PARSING
[smell-name]Superset
[smell-description]Some grammars represent a superset of the intended language. This may become a problem if the parser based on the grammar is to be used as a correctness oracle, since in this role it is inadequate.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPSH
[smell-category]PARSING
[smell-name]Shotgun
[smell-description]Shotgun parsing is a term used in cybersecurity to represent an architecture where a proper parser is substituted with lightweight treatment (by regular expression matches and direct string manipulation). The name comes from the fact that in a pipeline of tools built with such defects, the problems quickly multiply with each step when the receiver is applying Postel’s Law in trying to be relaxed with its input, and is known to cause all kinds of subtle bugs in software language processing.\nWe define the Shotgun smell as a situation when the grammatical bind is too loose on one of its ends.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPN
[smell-category]PARSING
[smell-name]NoDefault
[smell-description]There are certain tricks experienced grammar engineers use to improve the error handling. For example, consider a DSL where each statement starts with a keyword and ends with a period. An obvious improvement to the naïve approach would be to, for instance, once a keyword MAP is recognised, have a panic mode setup or some other semiparsing machinery to fail locally and report on an “error in a map statement” rather than pointlessly try to backtrack and fail at the general statement level. To do this, one has to have a special default case among the rules for each particular statement kind. This recipe is more often observed in grammars written for frameworks where ordered choice is more natural (TXL, PEGs, etc), and could take the form of Stmt := "MAP" MapStmt "." / "IF" IfStmt "." /··· / Id (!".")* ".". The lack of the last alternative in this example would be an indication of a NoDefault smell.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPA
[smell-category]PARSING
[smell-name]Action
[smell-description]Many realistic language workbenches draw the line to prevent endless growing of their notations, and introduce a concept of a “semantic action”, which is written like an annotation in the grammar and acts as a doorway to the mainstream language typical for the target platform. Obviously, since this action consists of code, the code can su er from one of the numerous code smells.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDE
[smell-category]DUPLICATION
[smell-name]Echo
[smell-description]A nonterminal definition is echoed if it is included in the grammar several times, each of which is identical to any other. Echoes were found in the Java Language Specification as a result of manual (not tool supported) creation of both the grammar and language documentation.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDC
[smell-category]DUPLICATION
[smell-name]Clone
[smell-description]Nonterminals that have exactly the same definitions, are only cluttering the grammar, and can be painlessly united.
[smell-aka]GDF
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDF
[smell-category]DUPLICATION
[smell-name]Foldable
[smell-description]This smell occurs when the clone is formed not between full definitions of two nonterminals, but when the right hand side of one nonterminal occurs as a subexpression in the right hand side of another nonterminal. Conceptually they are still clones and su er from all known consequences of coupled evolution.
[smell-aka]GDC
[smell-aka]GDCO
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDCO
[smell-category]DUPLICATION
[smell-name]Common
[smell-description]We may observe clones between two or more subexpressions found in different places in the grammar.
[smell-aka]GDC
[smell-aka]GDF
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDL
[smell-category]DUPLICATION
[smell-name]Lookalike
[smell-description]In mainstream clone detection research, people distinguish between clones of different types: “type 1”, "type 2", "type 3", and "type 4". For grammars, there is no developed theory of clone management, so the questions are open on what constitutes a proper clone, what classes of clones are there, which ones are useful to detect and which to refactor, etc. It makes sense to assume that clone detection in grammars will bear some similarity to contextual clones [35] that worked for another DSL with relatively few constructs, where clones were detected based on the context of clone candidate fragments, and not on their structure per se.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDP
[smell-category]DUPLICATION
[smell-name]Permuted
[smell-description]Clones modulo permutations (e.g., A | B vs B | A) are confusing: if the choice used in the notation is commutative, they are just Clones, otherwise if the choice is ordered, having both A / B and B / A within the same grammar is even more confusing for everyone.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSU
[smell-category]SPAGHETTI
[smell-name]Uncluster
[smell-description]Nonterminals that refer to one another, should be located close to one another. The longer the distance between the use of a nonterminal from its definition, the more the reader of the grammar will have to switch context. A lot of scrolling always means there is something smelly about how the gram- mar is set up. Moving the production rules that cause the scrolling closer to each other to form a cluster, will result in an easier grammar with more coherent structure.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSUS
[smell-category]SPAGHETTI
[smell-name]Unsequence
[smell-description]The order of the production rules in the grammar should be set up in a consistent manner, such that referred nonterminals in production rules refer either up or down in the grammar. If Uncluster and Splat are concerned with general placement of production rules, this smell is about how they need to be structured to keep the reading experience optimal.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSS
[smell-category]SPAGHETTI
[smell-name]StartInTheMiddle
[smell-description]To improve the readability and navigability of the grammar, its starting symbol should be on top or the bottom of the grammar, not lost somewhere in the middle.
[smell-aka]GSHC
[smell-ref]Mats2017
[smell-end]


[smell]
[smell-id]GSHA
[smell-category]SHORTAGE
[smell-name]AlmostAlphabet
[smell-description]The completeness of some character classes and terminal choices can be predicted, and compared to the actual value given by the grammar. For example, if a character class includes all Latin letters except one or all whitespace characters except \r, it may be an error.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSHC
[smell-category]SHORTAGE
[smell-name]ConfusingEntry
[smell-description]StartInTheMiddle addresses positioning of the starting symbol of the grammar, but there can be three more problems with it. (1) Some grammars do not have any start specified at all, having it to be inferred by heuristics (e.g., the only top nonterminal). (2) There can be multiple starts, especially for notations that exceed classic CFGs. This can indicate several independent grammars that got merged into one, or just several entry points into the grammar (which would allow, for example, to parse statements or expressions out of context—it is a not quite challenging exercise in theory, but extremely useful in practical grammarware engineering when integrating software languages with an IDE and a debugger). (3) The root symbol is properly marked as such, but is also referenced from other nonterminals in the grammar (so the starting symbol is not a top nonterminal).
[smell-aka]GSS
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSHD
[smell-category]SHORTAGE
[smell-name]Dead
[smell-description]All top (unused) nonterminals identified as not being the starting symbol(s) of the grammar, represent unreachable fragments.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSHB
[smell-category]SHORTAGE
[smell-name]Bottom
[smell-description]The lack of definition for nonterminals that are used within the grammar, is an obvious mistake that must be reported one way or another, and also possibly as a smell.\nThere are three main reasons for undefined nonterminals: (1) they were forgotten by the grammar engineer; (2) they are defined in a different module; (3) they are defined on a separate conceptual layer.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GSHDE
[smell-category]SHORTAGE
[smell-name]Debt
[smell-description]Similarly to Chant that covers up imperfect fragments with comments in natural language, there could be pieces missing entirely from the grammar and replaced with comments. If the comments admit clearly what is missing, use searchable tags like “TODO” or “FIXME” and are intended to use as a backlog.
[smell-aka]GNCH
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GMB
[smell-category]MIXTURE
[smell-name]BadLayout
[smell-description]Dealing with layout and whitespace can be very tricky, and, as any tricky process, there may be issues with it. Not specifying any layout may be harmful in some cases as well.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GMP
[smell-category]MIXTURE
[smell-name]Preprocessor
[smell-description]A preprocessor is a curious thing: it is essentially, for all intents and purposes, a compiler that processes the input text, expands macros, connects additional textual sources, performs variant compilation and other similar activities. On the other hand, it is so common to use it before the “actual” compiler, that some study books regard it as a separate phase of compilation.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPC
[smell-category]PROXY
[smell-name]Chain
[smell-description]Chain rules are a well-known smell in grammar engineering: it happens when a nonterminal is defined with only one production rule which has exactly one nonterminal as its right hand side. The “inner” nonterminal acts like a middle man and does not play a significant rule in structural commitments of the grammar.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPT
[smell-category]PROXY
[smell-name]Throwaway
[smell-description]A nonterminal that is used only once, may be useful to shorten production rules (see TooWide), and may occasionally convey a useful abstraction with its name. Beyond those circumstances it is a smell and a candidate for refactoring.
[smell-aka]GXTW
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPW
[smell-category]PROXY
[smell-name]Weak
[smell-description]When the right hand side of a nonterminal is formed from several symbols that happen to occur one after another, without forming a proper abstraction, this can hinder grammar’s understanding.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPG
[smell-category]PROXY
[smell-name]Ghost
[smell-description]If an expression, especially a Common subexpression, could have formed a proper abstraction, but is not made into a separate nonterminal, we speak of it as a Ghost. An example of a Ghost could be an omnipresent qualified identifier that is always used as Id ("." Id)*.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GPM
[smell-category]PROXY
[smell-name]Multitool
[smell-description]This takes place when a nonterminal violates the single responsibility principle, and represents several (hopefully related) abstractions, such as a type name and a variable name.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDD
[smell-category]DEPENDENCY
[smell-name]Diamond
[smell-description]A well-known pattern in dependency and inclusion is when a class A inherits from class X and class B also inherits from class X, but class C inherits from both A and B and thus gets to see double of each of X’s elements. The problem is solved differently in different programming and modelling languages—in grammars, it causes an ambiguity.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDR
[smell-category]DEPENDENCY
[smell-name]Rivalry
[smell-description]Modern frameworks are more advanced and versatile, they feature several kinds of negation, conjunction, ordered choices, precede and follow restrictions, etc. However, there is none that explicitly provides an exclusive disjunction combinator, even though it was the original intent behind the choice: thus, a statement may be a conditional statement or a print statement, but not both at the same time. This smell is about such situations: it occurs whenever languages of alternative siblings overlap and create an ambiguity.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDO
[smell-category]DEPENDENCY
[smell-name]Ouroboros
[smell-description]If nonterminals are mutually, say, left recursive, and have no non-recursive alternatives, they are useless and cannot express a proper syntactic commitment. However, a similar issue may be encountered on the level of modules, and it is harder to detect for a human because modular grammars are already stretching comprehension capabilities of a grammar engineer.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDS
[smell-category]DEPENDENCY
[smell-name]Soulmates
[smell-description]If enough information is available about the evolution of the grammar (e.g., in a form of a versioned repository or a piece of documentation describing all changes), one can notice two nonterminals having a so-called co-change relationship when each revision that changes one, also changes the other. The smell occurs when this co-change relationship in the revision log does not correspond to explicit dependencies between modules and nonterminals.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDSP
[smell-category]DEPENDENCY
[smell-name]Spillover
[smell-description]Spillover happens when some symbols that should have been a part of the nonterminal definition, are not included in its right hand side, and appended every time to its use. This creates a co-change relationship between the nonterminal and the context of its use. With Spillover, every time a definition of a nonterminal is changed in a particular way, all occurrences of the same nonterminal needs to be updated.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GDM
[smell-category]DEPENDENCY
[smell-name]Mythic
[smell-description]If a grammar contains a feature that is never exercised by any program in the actual codebase, it is a Mythic feature that, does not have to be supported for an analysis or migration tool to be useful and applicable.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTW
[smell-category]COMPLEXITY
[smell-name]TooWide
[smell-description]This smell is designed to recognise production rules which are too wide—that is, their right hand side is too long. There could be at least three ways to define what is “too long”: 1) The number of consequent terminals is too high, which is harmful because long streaks of consequent terminals obscure the syntactic structure. 2) The number of nonterminals is too high, which is harmful because it requires knowledge about referenced nonterminals to debug a grammar (so we should not count preterminals). 3) The number of metasymbols (stars, optionals, crosses, separator lists and other combinators) is too high, which is harmful because the importance of knowing the notation is stressed when a grammar engineer needs to understand such a production rule.
[smell-aka]GPT
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTR
[smell-category]COMPLEXITY
[smell-name]TooRamose
[smell-description]In grammars cyclomatic complexity is easy to estimate if we think of the parsing semantics, and it will be rather close for any other concrete application of the grammar. Alternatives and all kinds of disjunction obviously contribute to its increase, as well as repetition metasymbols. Conjunction, if present, also contributes to the branching since a construct like A & B means that both the parser and the grammar engineer will have to explore both branches related to A as well as to B.
[smell-aka]GXTN
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTRE
[smell-category]COMPLEXITY
[smell-name]TooRecursive
[smell-description]If recursion and mutual recursion are too prevalent in a grammar, it can be confusing even if it is not 1SidedRecursion.
[smell-aka]GPS
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTN
[smell-category]COMPLEXITY
[smell-name]TooNested
[smell-description]Subsequences (often called groups) may be used to avoid Misformat, but really hamper the understanding of the system if used excessively. This smell often correlates with production rules being TooRamose.
[smell-aka]GXTRE
[smell-aka]GCM
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTT
[smell-category]COMPLEXITY
[smell-name]TooTall
[smell-description]For each nonterminal we can calculate its minimal distance from the starting symbol, as the minimal number of productions in a full derivation that contains it. The maximum of all these distances for all nonterminals, is what is referred to as the height of the grammar. Out of two grammars of comparable size with respect to number of terminals, nonterminals and production rules, a taller grammar will be more complex to understand—thus, it is advisable to refactor a grammar that has grown too tall.
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTL
[smell-category]COMPLEXITY
[smell-name]TooLonely
[smell-description]A variant of the well-known Insufficient Modularisation smell, ported to grammars: if the size of a grammar is much larger than expected, the time has come to split it up in modules.
[smell-aka]GXTM
[smell-aka]GXGR
[smell-aka]GXTC
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTM
[smell-category]COMPLEXITY
[smell-name]TooModular
[smell-description]On the other side of the spectrum from TooLonely, a grammar can be too modular and split into so many modules that each of them is meaninglessly tiny, yet their combination is unbearably unintelligible.
[smell-aka]GXTL
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXGR
[smell-category]COMPLEXITY
[smell-name]Greedy
[smell-description]Similarly to TooLonely but not quite identical to it, there is a scenario when a grammar is modularised, but still insufficiently: in particular, if there is one module that is much greedier than the rest and does too much compared to any other module. In realistic grammars this smell is quite common, and the culture of proper modularisation with close to uniform distribution of responsibilities among modules, has not yet developed.
[smell-aka]GXTL
[smell-aka]GXLZ
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXLZ
[smell-category]COMPLEXITY
[smell-name]Lazy
[smell-description]The opposite of Greedy, a Lazy module is the one that does not do much: it is empty or contains just one nonterminal.
[smell-aka]GXGR
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]GXTC
[smell-category]COMPLEXITY
[smell-name]TooCoupled
[smell-description]Modularity can not only be broken or insufficient, it can also be weakened. A grammar split into several modules that have high coupling among them and low cohesion inside each of them, had better stayed as TooLonely.
[smell-aka]GXTL
[smell-ref]Mats2017
[smell-end]

[smell]
[smell-id]IMN
[smell-category]IMPL
[smell-name]Magic Number
[smell-description]This smell occurs when an unexplained number is used in an expression.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]IECB
[smell-category]IMPL
[smell-name]Empty Catch Block
[smell-description]This smell occurs when a catch block of an exception is empty.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]ICC
[smell-category]IMPL
[smell-name]Complex Conditional
[smell-description]This smell occurs when a conditional statement is complex.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]ILS
[smell-category]IMPL
[smell-name]Long Statement
[smell-description]This smell occurs when a statement is excessively lengthy.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]ILI
[smell-category]IMPL
[smell-name]Long Identifier
[smell-description]This smell occurs when an identifier is excessively lengthy.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]ICM
[smell-category]IMPL
[smell-name]Complex Method
[smell-description]This smell occurs when a method has high cyclomatic complexity.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]IVCC
[smell-category]IMPL
[smell-name]Virtual Method Call from Constructor
[smell-description]This smell occurs when a constructor calls a virtual method.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]IMD
[smell-category]IMPL
[smell-name]Missing Default
[smell-description]This smell occurs when a switch statement does not contain a default case.
[smell-aka]
[smell-ref]Tushar2017
[smell-end]

[smell]
[smell-id]IGMA
[smell-category]IMPL
[smell-name]“Get” - more than an accessor
[smell-description]A getter that performs actions other than returning the corresponding attribute without documenting it. \nExample: method getImageData which, no matter the attribute value, every time returns a new object.
[smell-aka]
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IIRB
[smell-category]IMPL
[smell-name]“Is” returns more than a Boolean
[smell-description]The name of a method is a predicate suggesting a true/false value in return. However the return type is not Boolean but rather a more complex type thus allowing a wider range of values without documenting them. \nExample: isValid with return type int.
[smell-aka]INAQ
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]ISMR
[smell-category]IMPL
[smell-name]“Set” method returns
[smell-description]A set method having a return type different than void and not documenting the return type/values with an appropriate comment.
[smell-aka]
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IENG
[smell-category]IMPL
[smell-name]Expecting but not getting a single instance
[smell-description]The name of a method indicates that a single object is returned but the return type is a collection. \nExample: method getExpansion returning a list.
[smell-aka]IEGC
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IVMC
[smell-category]IMPL
[smell-name]Validation method does not confirm
[smell-description]A validation method (e.g., name starting with “validate”, “check”, “ensure”) does not confirm the validation, i.e., the method neither provides a return value informing whether the validation was successful, nor documents how to proceed.
[smell-aka]ITMR
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IGNR
[smell-category]IMPL
[smell-name]“Get” method does not return
[smell-description]The name suggests that the method returns something (e.g., name starts with “get” or “return”) but the return type is void. The documentation should explain where the resulting data is stored and how to obtain it.
[smell-aka]
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]INAQ
[smell-category]IMPL
[smell-name]Not answered question
[smell-description]The name of a method is in the form of predicate whereas the return type is not Boolean. \nExample: method isValid with return type void.
[smell-aka]IIRB
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]ITMR
[smell-category]IMPL
[smell-name]Transform method does not return
[smell-description]The name of a method suggests the transformation of an object but there is no return value and it is not clear from the documentation where the result is stored. \nExample: method javaToNative with return type void.
[smell-aka]IVMC
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]IEGC
[smell-category]IMPL
[smell-name]Expecting but not getting a collection
[smell-description]The name of a method suggests that a collection should be returned but a single object or nothing is returned. \nExample: method getStats with return type Boolean.
[smell-aka]IENG
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]IMRO
[smell-category]IMPL
[smell-name]Method name and return type are opposite
[smell-description]The intent of the method suggested by its name is in contradiction with what it returns. \nExample: method disable with return type ControlEnableState. The inconsistency comes from “disable” and “enable” having opposite meanings.
[smell-aka]IATO
[smell-aka]IACO
[smell-aka]IACO
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]IMCO
[smell-category]IMPL
[smell-name]Method signature and comment are opposite
[smell-description]The documentation of a method is in contradiction with its declaration. \nExample: method isNavigateForwardEnabled is in contradiction with its comment documenting ”a back navigation”, as “forward” and “back” are antonyms.
[smell-aka]IATO
[smell-aka]IMRO
[smell-aka]IACO
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]ISOM
[smell-category]IMPL
[smell-name]Says one but contains many
[smell-description]The name of an attribute suggests a single instance, while its type suggests that the attribute stores a collection of objects. \nExample: attribute target of type Vector. It is unclear whether a change affects one or multiple instances in the collection.
[smell-aka]ISMO
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]INBN
[smell-category]IMPL
[smell-name]Name suggests Boolean but type does not
[smell-description]The name of an attribute suggests that its value is true or false, but its declaring type is not Boolean. \nExample: attribute isReached of type int[] where the declared type and values are not documented.
[smell-aka]
[smell-ref]Arnaoudova2016
[smell-end]


[smell]
[smell-id]ISMO
[smell-category]IMPL
[smell-name]Says many but contains one
[smell-description]The name of an attribute suggests multiple instances, but its type suggests a single one. \nExample: attribute stats of type Boolean. Documenting such inconsistencies avoids additional comprehension effort to understand the purpose of the attribute.
[smell-aka]ISOM
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IATO
[smell-category]IMPL
[smell-name]Attribute name and type are opposite
[smell-description]The name of an attribute is in contradiction with its type as they contain antonyms. \nExample: attribute start of type MAssociationEnd. The use of antonyms can induce wrong assumptions.
[smell-aka]IMCO
[smell-aka]IMRO
[smell-aka]IACO
[smell-ref]Arnaoudova2016
[smell-end]

[smell]
[smell-id]IACO
[smell-category]IMPL
[smell-name]Attribute signature and comment are opposite
[smell-description]The declaration of an attribute is in contradiction with its documentation. \nExample: attribute INCLUDE NAME DEFAULT whose comment documents an “exclude pattern”. Whether the pattern is included or excluded is thus unclear.
[smell-aka]IMCO
[smell-aka]IMRO
[smell-aka]IATO
[smell-ref]Arnaoudova2016
[smell-end]
